(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (global = global || self, factory(global.googleMapsReactHooks = {}, global.react));
})(this, (function (exports, React) {
  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }

  var GOOGLE_MAPS_API_URL = 'https://maps.googleapis.com/maps/api/js';
  /**
   * The Google Maps context
   */
  var GoogleMapsContext = React__default["default"].createContext({
    googleMapsAPIIsLoaded: false
  });
  /**
   * The global Google Maps provider
   */
  var GoogleMapsProvider = function GoogleMapsProvider(props) {
    var children = props.children,
      googleMapsAPIKey = props.googleMapsAPIKey,
      mapContainer = props.mapContainer,
      mapOptions = props.mapOptions,
      libraries = props.libraries,
      language = props.language,
      region = props.region,
      version = props.version,
      authReferrerPolicy = props.authReferrerPolicy,
      onLoadScript = props.onLoadScript,
      onLoadMap = props.onLoadMap;
    var _useState = React.useState(true),
      isLoadingAPI = _useState[0],
      setIsLoadingAPI = _useState[1];
    var _useState2 = React.useState(),
      map = _useState2[0],
      setMap = _useState2[1];
    // Handle Google Maps API loading
    // eslint-disable-next-line complexity
    React.useEffect(function () {
      var apiLoadingFinished = function apiLoadingFinished() {
        setIsLoadingAPI(false);
        onLoadScript && onLoadScript();
      };
      var defaultLanguage = navigator.language.slice(0, 2);
      var defaultRegion = navigator.language.slice(3, 5);
      /* eslint-disable camelcase */
      var params = new URLSearchParams(_extends({
        key: googleMapsAPIKey,
        language: language || defaultLanguage,
        region: region || defaultRegion
      }, (libraries == null ? void 0 : libraries.length) && {
        libraries: libraries.join(',')
      }, version && {
        v: version
      }, authReferrerPolicy && {
        auth_referrer_policy: authReferrerPolicy
      }));
      /* eslint-enable camelcase */
      var existingScriptTag = document.querySelector("script[src^=\"" + GOOGLE_MAPS_API_URL + "\"]");
      // Check if Google Maps API was loaded with the passed parameters
      if (existingScriptTag) {
        var loadedURL = new URL(existingScriptTag.src);
        var loadedParams = loadedURL.searchParams.toString();
        var passedParams = params.toString();
        if (loadedParams !== passedParams) {
          console.error('The Google Maps API Parameters passed to the `GoogleMapsProvider` components do not match. The Google Maps API can only be loaded once. Please make sure to pass the same API parameters to all of your `GoogleMapsProvider` components.', '\n\nExpected parameters:', Object.fromEntries(loadedURL.searchParams), '\n\nReceived parameters:', Object.fromEntries(params));
        }
      }
      if (typeof google === 'object' && typeof google.maps === 'object') {
        // Google Maps API is already loaded
        apiLoadingFinished();
      } else if (existingScriptTag) {
        // Google Maps API is already loading
        setIsLoadingAPI(true);
        var onload = existingScriptTag.onload;
        existingScriptTag.onload = function (event) {
          onload == null ? void 0 : onload.call(existingScriptTag, event);
          apiLoadingFinished();
        };
      } else {
        // Load Google Maps API
        setIsLoadingAPI(true);
        // Add google maps callback
        window.mapsCallback = function () {
          apiLoadingFinished();
        };
        params.set('callback', 'mapsCallback');
        var scriptTag = document.createElement('script');
        scriptTag.type = 'text/javascript';
        scriptTag.src = GOOGLE_MAPS_API_URL + "?" + params.toString();
        document.getElementsByTagName('head')[0].appendChild(scriptTag);
      }
      // Clean up Google Maps API
      return function () {
        // Remove all loaded Google Maps API scripts
        document.querySelectorAll('script[src^="https://maps.googleapis.com"]').forEach(function (script) {
          script.remove();
        });
        // Remove google.maps global
        if (typeof google === 'object' && typeof google.maps === 'object') {
          // @ts-ignore: The operand of a 'delete' operator must be optional.
          delete google.maps;
        }
      };
    }, [googleMapsAPIKey, JSON.stringify(libraries), language, region, version, authReferrerPolicy]);
    // Handle Google Maps map instance
    React.useEffect(function () {
      // Check for google.maps is needed because of Hot Module Replacement
      if (isLoadingAPI || !mapContainer || !(typeof google === 'object' && typeof google.maps === 'object')) {
        return function () {};
      }
      var newMap = new google.maps.Map(mapContainer, mapOptions);
      google.maps.event.addListenerOnce(newMap, 'idle', function () {
        if (onLoadMap && newMap) {
          onLoadMap(newMap);
        }
      });
      setMap(newMap);
      // Remove all map related event listeners
      return function () {
        if (newMap && typeof google === 'object' && typeof google.maps === 'object') {
          google.maps.event.clearInstanceListeners(newMap);
        }
      };
    }, [isLoadingAPI, mapContainer]);
    return /*#__PURE__*/React__default["default"].createElement(GoogleMapsContext.Provider, {
      value: {
        map: map,
        googleMapsAPIIsLoaded: !isLoadingAPI
      }
    }, children);
  };

  /**
   * Hook to get Google Maps Autocomplete Service instance
   */
  var useAutocompleteService = function useAutocompleteService() {
    var _useContext = React.useContext(GoogleMapsContext),
      googleMapsAPIIsLoaded = _useContext.googleMapsAPIIsLoaded;
    // Creates an Autocomplete Service instance
    var autocompleteService = React.useMemo(function () {
      // Wait for Google Maps API to be loaded
      if (!googleMapsAPIIsLoaded) {
        return null;
      }
      if (!google.maps.places) {
        throw Error("Places library missing. Add 'places' to the libraries array of GoogleMapsProvider.");
      }
      return new google.maps.places.AutocompleteService();
    }, [googleMapsAPIIsLoaded]);
    return autocompleteService;
  };

  /**
   * Hook to get a Google Maps Places Autocomplete instance
   * monitoring an input field
   */
  var useAutocomplete = function useAutocomplete(props) {
    var inputField = props.inputField,
      options = props.options,
      onPlaceChanged = props.onPlaceChanged;
    var placeChangedHandler = React.useRef(onPlaceChanged);
    var _useContext = React.useContext(GoogleMapsContext),
      googleMapsAPIIsLoaded = _useContext.googleMapsAPIIsLoaded;
    var _useState = React.useState(null),
      autocomplete = _useState[0],
      setAutocomplete = _useState[1];
    // Initializes the Google Maps Places Autocomplete
    React.useEffect(function () {
      // Wait for the Google Maps API and input element to be initialized
      if (!googleMapsAPIIsLoaded || !inputField) {
        return function () {};
      }
      if (!google.maps.places) {
        throw Error("Autocomplete library missing. Add 'places' to the libraries array of GoogleMapsProvider.");
      }
      // Create Autocomplete instance
      var autocompleteInstance = new google.maps.places.Autocomplete(inputField, options);
      setAutocomplete(autocompleteInstance);
      // Add places change listener to Autocomplete
      autocompleteInstance.addListener('place_changed', function () {
        var place = autocompleteInstance.getPlace();
        placeChangedHandler.current && placeChangedHandler.current(place);
      });
      // Clear listeners on unmount
      return function () {
        autocompleteInstance && google.maps.event.clearInstanceListeners(autocompleteInstance);
      };
    }, [googleMapsAPIIsLoaded, inputField, options]);
    return autocomplete;
  };

  /**
   * Hook to get Google Maps Places Directions Service instance
   */
  var useDirectionsService = function useDirectionsService(props) {
    if (props === void 0) {
      props = {};
    }
    var _props = props,
      renderOnMap = _props.renderOnMap,
      renderOptions = _props.renderOptions;
    var _useContext = React.useContext(GoogleMapsContext),
      googleMapsAPIIsLoaded = _useContext.googleMapsAPIIsLoaded,
      map = _useContext.map;
    // Creates a Directions Service instance
    var directionsService = React.useMemo(function () {
      // Wait for Google Maps API to be loaded
      if (!googleMapsAPIIsLoaded) {
        return null;
      }
      return new google.maps.DirectionsService();
    }, [googleMapsAPIIsLoaded]);
    // Creates a Directions Renderer instance
    var directionsRenderer = React.useMemo(function () {
      // Wait for map to be initialized
      if (!map || !renderOnMap) {
        return null;
      }
      var renderer = new google.maps.DirectionsRenderer(renderOptions);
      renderer.setMap(map);
      return renderer;
    }, [map, renderOnMap]);
    // Updates the directions renderer options
    React.useEffect(function () {
      if (!directionsRenderer) {
        return;
      }
      directionsRenderer.setOptions(renderOptions || {});
    }, [renderOptions]);
    // Custom Directions route request
    var findRoute = React.useCallback(function (request) {
      return new Promise(function (resolve, reject) {
        if (directionsService) {
          directionsService.route(request, function (result, status) {
            if (status !== google.maps.DirectionsStatus.OK || !result) {
              reject(status);
            } else {
              resolve(result);
            }
          });
        }
      });
    }, [directionsService]);
    // Custom Directions route request followed by directions rendering
    var findAndRenderRoute = React.useCallback(function (request) {
      return new Promise(function (resolve, reject) {
        if (directionsService) {
          directionsService.route(request, function (result, status) {
            if (status !== google.maps.DirectionsStatus.OK || !result) {
              reject(status);
            } else {
              if (directionsRenderer) {
                directionsRenderer.setDirections(result);
              }
              resolve(result);
            }
          });
        }
      });
    }, [directionsService, directionsRenderer]);
    // Renders directions route of given index
    var renderRouteOfIndex = function renderRouteOfIndex(index) {
      if (directionsRenderer) {
        directionsRenderer.setRouteIndex(index);
      }
    };
    return {
      directionsService: directionsService,
      directionsRenderer: directionsRenderer,
      findRoute: directionsService && findRoute,
      findAndRenderRoute: directionsService && directionsRenderer && findAndRenderRoute,
      renderRouteOfIndex: renderRouteOfIndex
    };
  };

  /**
   * Hook to get Distance Matrix Service instance
   */
  var useDistanceMatrixService = function useDistanceMatrixService() {
    var _useContext = React.useContext(GoogleMapsContext),
      googleMapsAPIIsLoaded = _useContext.googleMapsAPIIsLoaded;
    // Creates a Distance Matrix Service instance
    var distanceMatrixService = React.useMemo(function () {
      // Wait for Google Maps API to be loaded
      if (!googleMapsAPIIsLoaded) {
        return null;
      }
      if (!google.maps.DistanceMatrixService) {
        throw Error('Distance Matrix library missing.');
      }
      return new google.maps.DistanceMatrixService();
    }, [googleMapsAPIIsLoaded]);
    return distanceMatrixService;
  };

  /**
   * Hook to get Elevation Service instance
   */
  var useElevationService = function useElevationService() {
    var _useContext = React.useContext(GoogleMapsContext),
      googleMapsAPIIsLoaded = _useContext.googleMapsAPIIsLoaded;
    // Creates an Elevation Service instance
    var elevationService = React.useMemo(function () {
      // Wait for Google Maps API to be loaded
      if (!googleMapsAPIIsLoaded) {
        return null;
      }
      return new google.maps.ElevationService();
    }, [googleMapsAPIIsLoaded]);
    return elevationService;
  };

  /**
   * Hook to get Google Maps Geocoder instance
   */
  var useGeocodingService = function useGeocodingService() {
    var _useContext = React.useContext(GoogleMapsContext),
      googleMapsAPIIsLoaded = _useContext.googleMapsAPIIsLoaded;
    // Creates a Geocoder instance
    var geocoder = React.useMemo(function () {
      // Wait for Google Maps API to be loaded
      if (!googleMapsAPIIsLoaded) {
        return null;
      }
      return new google.maps.Geocoder();
    }, [googleMapsAPIIsLoaded]);
    return geocoder;
  };

  /**
   * Hook to get global map instance
   */
  var useGoogleMap = function useGoogleMap() {
    return React.useContext(GoogleMapsContext).map;
  };

  /**
   * Hook to get Max Zoom Service instance
   */
  var useMaxZoomService = function useMaxZoomService() {
    var _useContext = React.useContext(GoogleMapsContext),
      googleMapsAPIIsLoaded = _useContext.googleMapsAPIIsLoaded;
    // Creates a Max Zoom Service instance
    var maxZoomService = React.useMemo(function () {
      // Wait for Google Maps API to be loaded
      if (!googleMapsAPIIsLoaded) {
        return null;
      }
      return new google.maps.MaxZoomService();
    }, [googleMapsAPIIsLoaded]);
    return maxZoomService;
  };

  /**
   * Hook to get Google Maps Places Service instance
   */
  var usePlacesService = function usePlacesService(props) {
    var _useContext = React.useContext(GoogleMapsContext),
      map = _useContext.map,
      googleMapsAPIIsLoaded = _useContext.googleMapsAPIIsLoaded;
    var _useState = React.useState(null),
      placesService = _useState[0],
      setPlacesService = _useState[1];
    // Creates a Places Service instance
    React.useEffect(function () {
      if (!googleMapsAPIIsLoaded) {
        return;
      }
      if (!google.maps.places) {
        throw Error("Places library missing. Add 'places' to the libraries array of GoogleMapsProvider.");
      }
      // Create places service which renders attributions in the map container
      if ((props == null ? void 0 : props.divElement) === undefined) {
        // Wait for map to be initialized
        if (!map) {
          return;
        }
        var serviceMap = new google.maps.places.PlacesService(map);
        setPlacesService(serviceMap);
        return;
      }
      // Create places service which renders attributions in the passed div element
      // Wait for div element to be available
      if (!(props != null && props.divElement)) {
        return;
      }
      var serviceElement = new google.maps.places.PlacesService(props == null ? void 0 : props.divElement);
      setPlacesService(serviceElement);
    }, [googleMapsAPIIsLoaded, map, props == null ? void 0 : props.divElement]);
    return placesService;
  };

  /* eslint-disable complexity */
  /**
   * Hook to get Street View Panorama
   */
  var useStreetViewPanorama = function useStreetViewPanorama(props) {
    var divElement = props.divElement,
      position = props.position,
      pov = props.pov,
      zoom = props.zoom;
    var _useContext = React.useContext(GoogleMapsContext),
      googleMapsAPIIsLoaded = _useContext.googleMapsAPIIsLoaded,
      map = _useContext.map;
    var _useState = React.useState(null),
      streetViewPanorama = _useState[0],
      setStreetViewPanorama = _useState[1];
    // Creates a Street View instance
    React.useEffect(function () {
      // If no div element is passed, initialize a map with Street View Panorama
      if (!divElement) {
        // Wait for Google Maps map instance
        if (!map) {
          return function () {};
        }
        var newPanorama = map.getStreetView();
        if (pov) {
          newPanorama.setPov(pov);
        }
        if (position) {
          newPanorama.setPosition(position);
        }
        // eslint-disable-next-line no-eq-null
        if (zoom != null) {
          newPanorama.setZoom(zoom);
        }
        setStreetViewPanorama(newPanorama);
      } else {
        // Wait for Google Maps API
        if (!googleMapsAPIIsLoaded) {
          return function () {};
        }
        // If a div element is passed, initialize street view in the element
        var _newPanorama = new google.maps.StreetViewPanorama(divElement, {
          position: position,
          pov: pov,
          zoom: zoom
        });
        setStreetViewPanorama(_newPanorama);
      }
      return function () {
        if (!divElement && map) {
          map.setStreetView(null);
        }
      };
    }, [map, divElement]);
    return streetViewPanorama;
  };

  exports.GoogleMapsContext = GoogleMapsContext;
  exports.GoogleMapsProvider = GoogleMapsProvider;
  exports.useAutocomplete = useAutocomplete;
  exports.useAutocompleteService = useAutocompleteService;
  exports.useDirectionsService = useDirectionsService;
  exports.useDistanceMatrixService = useDistanceMatrixService;
  exports.useElevationService = useElevationService;
  exports.useGeocodingService = useGeocodingService;
  exports.useGoogleMap = useGoogleMap;
  exports.useMaxZoomService = useMaxZoomService;
  exports.usePlacesService = usePlacesService;
  exports.useStreetViewPanorama = useStreetViewPanorama;

}));
