import React, { useState, useEffect, useContext, useMemo, useRef, useCallback } from 'react';

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

const GOOGLE_MAPS_API_URL = 'https://maps.googleapis.com/maps/api/js';
/**
 * The Google Maps context
 */
const GoogleMapsContext = React.createContext({
  googleMapsAPIIsLoaded: false
});
/**
 * The global Google Maps provider
 */
const GoogleMapsProvider = props => {
  const {
    children,
    googleMapsAPIKey,
    mapContainer,
    mapOptions,
    libraries,
    language,
    region,
    version,
    authReferrerPolicy,
    onLoadScript,
    onLoadMap
  } = props;
  const [isLoadingAPI, setIsLoadingAPI] = useState(true);
  const [map, setMap] = useState();
  // Handle Google Maps API loading
  // eslint-disable-next-line complexity
  useEffect(() => {
    const apiLoadingFinished = () => {
      setIsLoadingAPI(false);
      onLoadScript && onLoadScript();
    };
    const defaultLanguage = navigator.language.slice(0, 2);
    const defaultRegion = navigator.language.slice(3, 5);
    /* eslint-disable camelcase */
    const params = new URLSearchParams(_extends({
      key: googleMapsAPIKey,
      language: language || defaultLanguage,
      region: region || defaultRegion
    }, (libraries == null ? void 0 : libraries.length) && {
      libraries: libraries.join(',')
    }, version && {
      v: version
    }, authReferrerPolicy && {
      auth_referrer_policy: authReferrerPolicy
    }));
    /* eslint-enable camelcase */
    const existingScriptTag = document.querySelector(`script[src^="${GOOGLE_MAPS_API_URL}"]`);
    // Check if Google Maps API was loaded with the passed parameters
    if (existingScriptTag) {
      const loadedURL = new URL(existingScriptTag.src);
      const loadedParams = loadedURL.searchParams.toString();
      const passedParams = params.toString();
      if (loadedParams !== passedParams) {
        console.error('The Google Maps API Parameters passed to the `GoogleMapsProvider` components do not match. The Google Maps API can only be loaded once. Please make sure to pass the same API parameters to all of your `GoogleMapsProvider` components.', '\n\nExpected parameters:', Object.fromEntries(loadedURL.searchParams), '\n\nReceived parameters:', Object.fromEntries(params));
      }
    }
    if (typeof google === 'object' && typeof google.maps === 'object') {
      // Google Maps API is already loaded
      apiLoadingFinished();
    } else if (existingScriptTag) {
      // Google Maps API is already loading
      setIsLoadingAPI(true);
      const onload = existingScriptTag.onload;
      existingScriptTag.onload = event => {
        onload == null ? void 0 : onload.call(existingScriptTag, event);
        apiLoadingFinished();
      };
    } else {
      // Load Google Maps API
      setIsLoadingAPI(true);
      // Add google maps callback
      window.mapsCallback = () => {
        apiLoadingFinished();
      };
      params.set('callback', 'mapsCallback');
      const scriptTag = document.createElement('script');
      scriptTag.type = 'text/javascript';
      scriptTag.src = `${GOOGLE_MAPS_API_URL}?${params.toString()}`;
      document.getElementsByTagName('head')[0].appendChild(scriptTag);
    }
    // Clean up Google Maps API
    return () => {
      // Remove all loaded Google Maps API scripts
      document.querySelectorAll('script[src^="https://maps.googleapis.com"]').forEach(script => {
        script.remove();
      });
      // Remove google.maps global
      if (typeof google === 'object' && typeof google.maps === 'object') {
        // @ts-ignore: The operand of a 'delete' operator must be optional.
        delete google.maps;
      }
    };
  }, [googleMapsAPIKey, JSON.stringify(libraries), language, region, version, authReferrerPolicy]);
  // Handle Google Maps map instance
  useEffect(() => {
    // Check for google.maps is needed because of Hot Module Replacement
    if (isLoadingAPI || !mapContainer || !(typeof google === 'object' && typeof google.maps === 'object')) {
      return () => {};
    }
    const newMap = new google.maps.Map(mapContainer, mapOptions);
    google.maps.event.addListenerOnce(newMap, 'idle', () => {
      if (onLoadMap && newMap) {
        onLoadMap(newMap);
      }
    });
    setMap(newMap);
    // Remove all map related event listeners
    return () => {
      if (newMap && typeof google === 'object' && typeof google.maps === 'object') {
        google.maps.event.clearInstanceListeners(newMap);
      }
    };
  }, [isLoadingAPI, mapContainer]);
  return /*#__PURE__*/React.createElement(GoogleMapsContext.Provider, {
    value: {
      map,
      googleMapsAPIIsLoaded: !isLoadingAPI
    }
  }, children);
};

/**
 * Hook to get Google Maps Autocomplete Service instance
 */
const useAutocompleteService = () => {
  const {
    googleMapsAPIIsLoaded
  } = useContext(GoogleMapsContext);
  // Creates an Autocomplete Service instance
  const autocompleteService = useMemo(() => {
    // Wait for Google Maps API to be loaded
    if (!googleMapsAPIIsLoaded) {
      return null;
    }
    if (!google.maps.places) {
      throw Error("Places library missing. Add 'places' to the libraries array of GoogleMapsProvider.");
    }
    return new google.maps.places.AutocompleteService();
  }, [googleMapsAPIIsLoaded]);
  return autocompleteService;
};

/**
 * Hook to get a Google Maps Places Autocomplete instance
 * monitoring an input field
 */
const useAutocomplete = props => {
  const {
    inputField,
    options,
    onPlaceChanged
  } = props;
  const placeChangedHandler = useRef(onPlaceChanged);
  const {
    googleMapsAPIIsLoaded
  } = useContext(GoogleMapsContext);
  const [autocomplete, setAutocomplete] = useState(null);
  // Initializes the Google Maps Places Autocomplete
  useEffect(() => {
    // Wait for the Google Maps API and input element to be initialized
    if (!googleMapsAPIIsLoaded || !inputField) {
      return () => {};
    }
    if (!google.maps.places) {
      throw Error("Autocomplete library missing. Add 'places' to the libraries array of GoogleMapsProvider.");
    }
    // Create Autocomplete instance
    const autocompleteInstance = new google.maps.places.Autocomplete(inputField, options);
    setAutocomplete(autocompleteInstance);
    // Add places change listener to Autocomplete
    autocompleteInstance.addListener('place_changed', () => {
      const place = autocompleteInstance.getPlace();
      placeChangedHandler.current && placeChangedHandler.current(place);
    });
    // Clear listeners on unmount
    return () => {
      autocompleteInstance && google.maps.event.clearInstanceListeners(autocompleteInstance);
    };
  }, [googleMapsAPIIsLoaded, inputField, options]);
  return autocomplete;
};

/**
 * Hook to get Google Maps Places Directions Service instance
 */
const useDirectionsService = (props = {}) => {
  const {
    renderOnMap,
    renderOptions
  } = props;
  const {
    googleMapsAPIIsLoaded,
    map
  } = useContext(GoogleMapsContext);
  // Creates a Directions Service instance
  const directionsService = useMemo(() => {
    // Wait for Google Maps API to be loaded
    if (!googleMapsAPIIsLoaded) {
      return null;
    }
    return new google.maps.DirectionsService();
  }, [googleMapsAPIIsLoaded]);
  // Creates a Directions Renderer instance
  const directionsRenderer = useMemo(() => {
    // Wait for map to be initialized
    if (!map || !renderOnMap) {
      return null;
    }
    const renderer = new google.maps.DirectionsRenderer(renderOptions);
    renderer.setMap(map);
    return renderer;
  }, [map, renderOnMap]);
  // Updates the directions renderer options
  useEffect(() => {
    if (!directionsRenderer) {
      return;
    }
    directionsRenderer.setOptions(renderOptions || {});
  }, [renderOptions]);
  // Custom Directions route request
  const findRoute = useCallback(request => new Promise((resolve, reject) => {
    if (directionsService) {
      directionsService.route(request, (result, status) => {
        if (status !== google.maps.DirectionsStatus.OK || !result) {
          reject(status);
        } else {
          resolve(result);
        }
      });
    }
  }), [directionsService]);
  // Custom Directions route request followed by directions rendering
  const findAndRenderRoute = useCallback(request => new Promise((resolve, reject) => {
    if (directionsService) {
      directionsService.route(request, (result, status) => {
        if (status !== google.maps.DirectionsStatus.OK || !result) {
          reject(status);
        } else {
          if (directionsRenderer) {
            directionsRenderer.setDirections(result);
          }
          resolve(result);
        }
      });
    }
  }), [directionsService, directionsRenderer]);
  // Renders directions route of given index
  const renderRouteOfIndex = index => {
    if (directionsRenderer) {
      directionsRenderer.setRouteIndex(index);
    }
  };
  return {
    directionsService,
    directionsRenderer,
    findRoute: directionsService && findRoute,
    findAndRenderRoute: directionsService && directionsRenderer && findAndRenderRoute,
    renderRouteOfIndex
  };
};

/**
 * Hook to get Distance Matrix Service instance
 */
const useDistanceMatrixService = () => {
  const {
    googleMapsAPIIsLoaded
  } = useContext(GoogleMapsContext);
  // Creates a Distance Matrix Service instance
  const distanceMatrixService = useMemo(() => {
    // Wait for Google Maps API to be loaded
    if (!googleMapsAPIIsLoaded) {
      return null;
    }
    if (!google.maps.DistanceMatrixService) {
      throw Error('Distance Matrix library missing.');
    }
    return new google.maps.DistanceMatrixService();
  }, [googleMapsAPIIsLoaded]);
  return distanceMatrixService;
};

/**
 * Hook to get Elevation Service instance
 */
const useElevationService = () => {
  const {
    googleMapsAPIIsLoaded
  } = useContext(GoogleMapsContext);
  // Creates an Elevation Service instance
  const elevationService = useMemo(() => {
    // Wait for Google Maps API to be loaded
    if (!googleMapsAPIIsLoaded) {
      return null;
    }
    return new google.maps.ElevationService();
  }, [googleMapsAPIIsLoaded]);
  return elevationService;
};

/**
 * Hook to get Google Maps Geocoder instance
 */
const useGeocodingService = () => {
  const {
    googleMapsAPIIsLoaded
  } = useContext(GoogleMapsContext);
  // Creates a Geocoder instance
  const geocoder = useMemo(() => {
    // Wait for Google Maps API to be loaded
    if (!googleMapsAPIIsLoaded) {
      return null;
    }
    return new google.maps.Geocoder();
  }, [googleMapsAPIIsLoaded]);
  return geocoder;
};

/**
 * Hook to get global map instance
 */
const useGoogleMap = () => useContext(GoogleMapsContext).map;

/**
 * Hook to get Max Zoom Service instance
 */
const useMaxZoomService = () => {
  const {
    googleMapsAPIIsLoaded
  } = useContext(GoogleMapsContext);
  // Creates a Max Zoom Service instance
  const maxZoomService = useMemo(() => {
    // Wait for Google Maps API to be loaded
    if (!googleMapsAPIIsLoaded) {
      return null;
    }
    return new google.maps.MaxZoomService();
  }, [googleMapsAPIIsLoaded]);
  return maxZoomService;
};

/**
 * Hook to get Google Maps Places Service instance
 */
const usePlacesService = props => {
  const {
    map,
    googleMapsAPIIsLoaded
  } = useContext(GoogleMapsContext);
  const [placesService, setPlacesService] = useState(null);
  // Creates a Places Service instance
  useEffect(() => {
    if (!googleMapsAPIIsLoaded) {
      return;
    }
    if (!google.maps.places) {
      throw Error("Places library missing. Add 'places' to the libraries array of GoogleMapsProvider.");
    }
    // Create places service which renders attributions in the map container
    if ((props == null ? void 0 : props.divElement) === undefined) {
      // Wait for map to be initialized
      if (!map) {
        return;
      }
      const serviceMap = new google.maps.places.PlacesService(map);
      setPlacesService(serviceMap);
      return;
    }
    // Create places service which renders attributions in the passed div element
    // Wait for div element to be available
    if (!(props != null && props.divElement)) {
      return;
    }
    const serviceElement = new google.maps.places.PlacesService(props == null ? void 0 : props.divElement);
    setPlacesService(serviceElement);
  }, [googleMapsAPIIsLoaded, map, props == null ? void 0 : props.divElement]);
  return placesService;
};

/* eslint-disable complexity */
/**
 * Hook to get Street View Panorama
 */
const useStreetViewPanorama = props => {
  const {
    divElement,
    position,
    pov,
    zoom
  } = props;
  const {
    googleMapsAPIIsLoaded,
    map
  } = useContext(GoogleMapsContext);
  const [streetViewPanorama, setStreetViewPanorama] = useState(null);
  // Creates a Street View instance
  useEffect(() => {
    // If no div element is passed, initialize a map with Street View Panorama
    if (!divElement) {
      // Wait for Google Maps map instance
      if (!map) {
        return () => {};
      }
      const newPanorama = map.getStreetView();
      if (pov) {
        newPanorama.setPov(pov);
      }
      if (position) {
        newPanorama.setPosition(position);
      }
      // eslint-disable-next-line no-eq-null
      if (zoom != null) {
        newPanorama.setZoom(zoom);
      }
      setStreetViewPanorama(newPanorama);
    } else {
      // Wait for Google Maps API
      if (!googleMapsAPIIsLoaded) {
        return () => {};
      }
      // If a div element is passed, initialize street view in the element
      const newPanorama = new google.maps.StreetViewPanorama(divElement, {
        position,
        pov,
        zoom
      });
      setStreetViewPanorama(newPanorama);
    }
    return () => {
      if (!divElement && map) {
        map.setStreetView(null);
      }
    };
  }, [map, divElement]);
  return streetViewPanorama;
};

export { GoogleMapsContext, GoogleMapsProvider, useAutocomplete, useAutocompleteService, useDirectionsService, useDistanceMatrixService, useElevationService, useGeocodingService, useGoogleMap, useMaxZoomService, usePlacesService, useStreetViewPanorama };
